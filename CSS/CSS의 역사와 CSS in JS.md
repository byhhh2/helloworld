# CSS의 역사와 CSS in JS

## CSS는 왜 탄생했는가?

웹은 문서를 공유하기 위해 탄생했고, 문서를 잘 보여주기 위해 서식이 만들어졌다. 

스타일을 추가하기 위해 HTML 태그에 style 속성을 이용하여 inline으로 스타일을 적용할 수 있었다. 이는 문제점이 있는데,

1. 공통 스타일을 작성해주고 싶으면 매번 반복해서 태그를 찾아 스타일을 작성해주어야 한다. 
2. 스타일에 변경사항이 생겼을 때 그 부분을 일일이 찾아서 바꿔주어야 한다. 

서식과 데이터가 복잡하게 공존하게 되면서 서식과 콘텐츠를 분리해야할 필요성이 생겼다. 이를 위해 탄생한 것이 CSS다.

## CSS란?

HTML에서 스타일만 분리하여 반복적인 부분을 일괄적으로 적용해줄 수 있게 한다.

### CSS Ruleset

1. 별도의 스타일을 선언(Declarations)한다. 
2. 원하는 태그를 찾아서 선택(Seletor)하여 스타일을 적용한다. 
- 선택자(Selector)와 선언(Declarations)를 합쳐 CSS Ruleset이라고 부른다.

```css
strong {
	color: red;
}

/* 

strong : 선택자(Selector)
{ .. } : 선언(Declarations)

*/
```

### Cascade와 Specificity

CSS는 여러 개의 스타일을 일괄적으로 적용하는 방식이다 보니 Ruleset의 적용 대상과 서식이 겹칠 경우 **어떤 서식을 우선으로 할지** 규칙이 필요했다. 

- **Cascade** - 종속적으로 퍼져나가는 모양
    - 서식을 겹겹이 덧칠해 나가되 단순한 것(기초)을 먼저 적용하고, 구체적인 것을 나중에 적용한다.
- **Specificity** - 특성, 명시도
    - CSS는 작성된 순서가 아니라 CSS rule이 가지고 있는 고유의 명시도(Specificity)에 따라 우선순위가 다르게 적용된다.
    - **(예시)** `h1 등 유형 선택자 < .class 클래스 선택자 < #id 아이디 선택자` 순으로 명시도가 높아진다. 즉 높은 명시도를 가진 스타일이 기존 CSS를 덮어 씌울 수 있다.
    - **(문제)** rule마다 고유의 specificity 있어서 기존의 CSS를 덮어 쓰기 위해 복잡한 selector, !important 키워드를 사용해서 우선 순위를 변경하는 코드를 남발하게 되었다.

## CSS에게 문제가 생겼다.

### 우선 순위 조정을 위해 Selector가 복잡해져갔다. 이를 해결하기 위해 Sass가 등장한다.

이전에는 백앤드 개발자가 HTML 문서를 작성하는 주체였다. 스타일을 변경하는 사람은 HTML을 건들지 않고 CSS만으로 디자인을 해야했다. 즉, HTML을 먼저 만들고 CSS로 나중에 커스텀하는 방식이다. 이 HTML을 수정할 수 없으니 원하는 디자인을 위해서는 고도화된 selector가 필요하게 된다. 

한 요소의 스타일을 적용하기 위해 우선 순위 조정을 위해 복잡한 selector를 사용하고, 

복잡한 selector로 인해 specificity가 높아지고,

또 새로운 스타일로 우선 순위를 적용하기 위해 더 높은 specificity를 위한 selector가 필요하고 … 이로 인해 CSS가 어렵고 복잡해진다. 

**Sass**

- CSS를 확장하여 만들어진 것. 추가적인 문법으로 작성하면 CSS로 변환시켜주는 pre-processor다.
- 추가적인 문법 : nested한 selector, variable 등록 가능

### 프론트엔드의 탄생과 컴포넌트 개발 방식

프론트엔드 개발에서 AJAX가 등장하며 백앤드 측에서 HTML이 아닌 JSON 데이터를 만들게 되었다. 이후 HTML을 CSS와 함께 작성하는 방식으로 개발을 하게 된다. 

이를 통해 복잡한 selector를 사용해야할 빈도가 줄어들었다. 

웹 어플리케이션 영역이 확대되고 web framework가 만들어지면서 웹 사이트가 복잡해지기 시작한다. 이런 이유로 문서 기반이 아니라 **컴포넌트** 기반의 개발 방식이 자리 잡게 된다. JS는 지속적으로 발전해왔지만 CSS는 그만큼의 속도를 따라오지 못한다. CSS는 예전에 문서를 꾸미기 위한 스펙들을 가지고 있었고, 앱을 만들기 위해 온갖 방법을 동원해 ‘가운데 정렬’을 해야했다. 

모든 문서에 일괄 적용을 위해 만들어진 기능들이, 웹 앱 제작면으로 보니 다른 컴포넌트 영역의 스타일을 수정할 수 있다는 점이 문제가 되었다. (cascade, specificity, global scope) 

## 문제를 해결하려는 방법론들 등장

웹이 급격하게 발전하면서 새로운 요구사항을 이미 만들어진 스펙이 따라오지 못했고, 어떻게든 방법을 찾다보니 CSS 스펙을 차용해서 새로운 방법을 만들어내는 것

### 방법론이 해결하려는 문제는?

- 여러 명이 작업할 때 공통적인 아키텍처가 있어야 한다.
- cascade와 specificity를 관리해야 한다.

### 이름 컨벤션을 통해 해결하려 한다.

- **BEM, OOCSS, SMACSS** 같은 방법론의 등장
- BEM (승자) - Block Element Modifier
    - selector를 class 방식으로만 작성한다.
    - 간결하고 직관적이다. 컨벤션이 단순하다.
    - `감싸고 있는 block요소`__`내부 element`—`속성`
    - 종속 관계가 없고, speciticity가 하나로 관리된다. (class 이름 하나로 종속 관계와 세부 사항을 지정한다.)

## CSS 스펙의 진화

- 레이아웃을 위한 CSS 스펙이 2013년 정식 등장 (Flexbox)
- 디자이너와 프론트엔드 개발자의 영역이 분리되면서 디자이너가 준 디자인을 통해 적절한 구조를 만들고, 컴포넌트 구조를 잘 만들어내는 능력이 더 중요해졌다.
- IE가 2015년을 기점으로 업데이트를 중단했다. IE는 점유율이 높은 브라우저였기 때문에 새로운 CSS 스펙이 나오더라도 개발자들이 꺼려하게 된다. 이것이 CSS에 대한 개발자들의 관심이 덜한 원인이 되었다. ⇒ 이런 이유로 **CSS 문제점을 JS로 해결하려는 시도들이 생겨난다.**

## CSS의 구조적인 문제는?

- global namespace
    - 스타일이 글로벌로 선언되어 중복되지 않는 class이름을 만들어내야 했다.
- minification
    - 중복되지 않는 class이름을 위해 긴 클래스 이름을 사용하여 문서 사이즈가 커진다.
- sharing constants
    - css가 분리되어 있어 JS의 상태값을 공유하기가 어렵다.
- non-deterministic resolution
    - css 로드 순서에 따라 우선순위가 달라지기 때문에 이를 기억하고 있어야 한다.
- isolation
    - css는 부모로부터 스타일이 상속되므로 하위 컴포넌트가 영향을 받는다.

CSS in JS는 이런 문제들을 해결한다. 

> **selector를 쓰는게 좋지 못한 이유**
> 
> 
> selector를 쓰면 specificity 관리가 어려워진다. 
> 
> BEM도 마찬가지로 하나의 specificity를 갖는 방식으로 진화한 것
> 
> (class만 사용) 
> 

## 이제는 JS로 해결한다.

### CSS Modules

- global scope로 인해 컴포넌트와 css간의 구조와 범위가 일치하지 않는 문제 해결
- 컴포넌트에서 css를 불러와서 컴포넌트에서만 적용이 될 수 있도록 컴파일을 해주는 도구
- global scope를 해결하면서 BEM같은 방법론이 더 이상 필요하지 않게 된다.

### Tailwind CSS

- utility first !
- atomic한 css
- 시맨틱 방식이 떠오르는 패러다임이 되면서 유틸리티한 방식은 옳지 않은 방식으로 여겨졌다. tailwind는 이런 방식을 일부 차용이 아니라 전면적으로 사용하면서 패러다임을 쉬프트한다.
- 왜 tailwind인가?
    - 웹 개발은 이젠 프론트가 직접 HTML, CSS를 조작한다.
    - CSS로 개발하는 것보다 HTML을 다루는게 편하고 side effect가 적다.
    - 대부분의 서비스들이 하나의 디자인 시스템을 가지므로 여러 개의 스타일 시트를 만들 필요가 없다.
    - atomic한 css는 모두 같은 specificity한 class로 구성되므로 새롭게 css를 작성하지 않아도 되어 **추가적인 css 관리가 필요하지 않다.**
    - 이름을 짓기 위한 고민을 하지 않아도 된다.

### CSS in JS

- Styled-Component의 흥행과 React의 압도적인 점유율로 인해 새로운 강자
- 런타임에 CSS를 생성한다. (이는 Zero Time CSS와 같은 컨셉으로 해결하려 노력중)
- class 이름이 빌드 타임에서 유니크하게 변경된다. (global namespace 해결)
- 컴포넌트와 CSS가 동일 파일 내에 존재하여 스타일 수정, 삭제가 용이하다.
- CSS 코드가 JS에 작성되므로 컴포넌트 상태가 공유 가능하다.
- CSS가 컴포넌트 스코프로 적용되므로 우선순위에 따른 문제가 없다.
- **(단점)** 테마 등의 공통 역역, 일부 유틸리티를 어떻게 해결하는가?
- **(단점)** CSS in JS는 상태값이 따라 동적으로 CSS가 추가되는 구조이다. 그렇기 때문에 빌드 시간에 CSS 코드로 변환될 수 없다. 즉, 런타임에 CSS로 변환되기 때문에 빌드 시간에 변환되는 CSS Modules보다 렌더링 속도가 느리다.

### On Demand Atomic CSS

- tailwind는 미리 만들어둔 CSS로는 한계가 있었고, 이런 부분을 미리 설정해야 한다는 점에 지적을 받아온다.
- CSS를 미리 만들어두는 방식이 아니라 필요한 수치를 입력하면 자동으로 CSS를 생성해주는 주문형(on-demand) Atomic CSS 패러다임이 등장
- UnoCSS

**참고**

- [카카오웹툰은 CSS를 어떻게 작성하고 있을까?](https://fe-developers.kakaoent.com/2022/220210-css-in-kakaowebtoon/)
- [역사로 알아보는 CSS가 어려워진 이유](https://yozm.wishket.com/magazine/detail/1319/) - 1
- [역사로 알아보는 CSS가 어려워진 이유 - 2](https://yozm.wishket.com/magazine/detail/1326/)
